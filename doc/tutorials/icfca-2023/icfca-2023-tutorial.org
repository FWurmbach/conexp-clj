#+property: header-args :wrap src text
#+property: header-args:text :eval never

* ~conexp-clj~ Tutorial at ICFCA 2023

This is a tutorial for the ICFCA 2023. It contains an example analysis of a 
formal context with the tool ~conexp-clj~.

** Basic FCA operations

*** Getting started

To run ~conexp-clj~, a Java Runtime Environment with version 1.8 or higher is necessary.
A pre-compiled version of ~conexp-clj~ is available [[https://algebra20.de/conexp/][here]]. The jar file can be used 
like this:

#+begin_src sh :eval never
java -jar conexp-clj-2.3.0-SNAPSHOT-standalone.jar
#+end_src

A prompt for ~conexp-clj~ like this will appear:

#+RESULTS
#+begin_src text
conexp.main=>
#+end_src

*** Read a context
 
During the workshop, you can use your own context or, for example, the 
[[../../../testing-data/Living-Beings-and-Water.ctx][Living-Beings-and-Water]] or [[../../../testing-data/ben-and-jerrys.ctx][Ben-and-Jerrys]] context. The examples in this tutorial use the 
Ben-and-Jerrys ice cream context.

It is possible to read formal contexts in several formats, e.g., Burmeister and csv. 
A more detailed overview of the context formats can be found in [[../../IO.org][Input/Output of Formal Contexts]]. 
In addition, you can show all input formats with 

#+begin_src clojure :exports both
(list-context-input-formats)
#+end_src

#+begin_src text
(:burmeister :csv :conexp :named-binary-csv :anonymous-burmeister :graphml :simple :binary-csv :fcalgs :colibri :json :galicia)
#+end_src

When reading a context, the format will be automatically determined:

#+begin_src clojure :results silent
(def ben-and-jerrys-ctx (read-context "path-to-file/ben-and-jerrys.ctx"))
#+end_src

To see the formal context, evaluate the ~ben-and-jerrys-ctx~ variable explicitly.

#+begin_src clojure :exports both
ben-and-jerrys-ctx
#+end_src

The ben-and-jerrys context contains ice cream types as objects and ingredients as 
attributes:

#+RESULTS
#+begin_src text
                       |Brownie Caramel Caramel Ice Choco Ice Choco Pieces Dough Peanut Butter Peanut Ice Vanilla 
-----------------------+------------------------------------------------------------------------------------------
Caramel Chew Chew      |.       x       x           .         x            .     .             .          .       
Caramel Sutra          |.       x       x           x         x            .     .             .          .       
Cookie Dough           |.       .       .           .         x            x     .             .          x       
Fudge Brownie          |x       .       .           x         .            .     .             .          .       
Half Baked             |x       .       .           x         x            x     .             .          x       
Peanut Butter Cup      |.       .       .           .         x            .     x             x          .       
Salted Caramel Brownie |x       x       .           .         x            .     .             .          x       
#+end_src

*** Remove objects and attributes

In case you want to make your formal context smaller (to decrease computation time 
for some of the later analysis steps), there are several options. You can create a new 
formal context that only contains the objects and attributes that you want to keep. The 
new incidence relation is derived from the old one by only considering the object-attribute 
pairs of objects and attributes that are contained in the new context.

#+begin_src clojure :results silent
(def small-ben-and-jerrys-ctx 
  (make-context
    ["Cookie Dough" "Half Baked" "Fudge Brownie"]
    ["Brownie" "Choco Ice" "Choco Pieces" "Dough" "Vanilla"]
    (fn [A B]
      (contains? (incidence-relation ben-and-jerrys-ctx) [A B]))))
#+end_src

The resulting context of this example is:

#+begin_src clojure :exports both
small-ben-and-jerrys-ctx
#+end_src

#+RESULTS
#+begin_src text
              |Brownie Choco Ice Choco Pieces Dough Vanilla 
--------------+---------------------------------------------
Cookie Dough  |.       .         x            x     x       
Fudge Brownie |x       x         .            .     .       
Half Baked    |x       x         x            x     x     
#+end_src

With the function ~rename-attributes~, it is also possible to rename attributes and 
combine several attributes in one, e.g., ~Choco Ice~ and ~Choco Pieces~ in the new 
attribute ~Choco~ and ~Peanut Butter~ and ~Peanut Ice~ in ~Peanut~.

#+begin_src clojure :results silent
(rename-attributes ben-and-jerrys-ctx 
  {"Brownie" "Brownie"
   "Caramel" "Caramel"
   "Caramel Ice" "Caramel"
   "Choco Ice" "Choco"
   "Choco Pieces" "Choco"
   "Dough" "Dough"
   "Peanut Butter" "Peanut"
   "Peanut Ice" "Peanut"
   "Vanilla" "Vanilla"})
#+end_src

#+RESULTS
#+begin_src text
                       |Brownie Caramel Choco Dough Peanut Vanilla 
-----------------------+-------------------------------------------
Caramel Chew Chew      |.       x       x     .     .      .       
Caramel Sutra          |.       x       x     .     .      .       
Cookie Dough           |.       .       x     x     .      x       
Fudge Brownie          |x       .       x     .     .      .       
Half Baked             |x       .       x     x     .      x       
Peanut Butter Cup      |.       .       x     .     x      .       
Salted Caramel Brownie |x       x       x     .     .      x       
#+end_src

The same can be applied to objects with ~rename-objects~.

*** Reduce, clarify

With ~reduced?~ and ~clarified?~, you can check if a context is reduced or clarified. 
The attributes, objects and the whole context can be reduced with ~reduce-attributes~, 
~reduce-objects~ and ~reduce-context~. The same applies to ~clarify~. 

The whole example context can be clarified as follows:

#+begin_src clojure :results silent
(def ben-and-jerrys-clarified
  (clarify-context ben-and-jerrys-ctx)
#+end_src

#+begin_src clojure :exports both
ben-and-jerrys-clarified
#+end_src

#+RESULTS
#+begin_src text
                       |Brownie Caramel Caramel Ice Choco Ice Choco Pieces Dough Peanut Ice Vanilla 
-----------------------+----------------------------------------------------------------------------
Caramel Chew Chew      |.       x       x           .         x            .     .          .       
Caramel Sutra          |.       x       x           x         x            .     .          .       
Cookie Dough           |.       .       .           .         x            x     .          x       
Fudge Brownie          |x       .       .           x         .            .     .          .       
Half Baked             |x       .       .           x         x            x     .          x       
Peanut Butter Cup      |.       .       .           .         x            .     x          .       
Salted Caramel Brownie |x       x       .           .         x            .     .          x       
#+end_src

As the attributes ~Peanut Butter~ and ~Peanut Ice~ have the same derivation, one of them (in this 
case ~Peanut Butter~ is removed.

*** Compute the concept lattice

The extents and intents of a formal context can be computed via:

#+begin_src clojure :export :both
(extents ben-and-jerrys-ctx)
#+end_src

#+RESULTS
#+begin_src text
(#{}
 #{"Half Baked"}
 #{"Half Baked" "Cookie Dough"}
 #{"Salted Caramel Brownie"}
 #{"Salted Caramel Brownie" "Half Baked"}
 #{"Salted Caramel Brownie" "Half Baked" "Cookie Dough"}
 #{"Caramel Sutra"}
 #{"Caramel Sutra" "Half Baked"}
 #{"Caramel Sutra" "Caramel Chew Chew"}
 #{"Caramel Sutra" "Salted Caramel Brownie" "Caramel Chew Chew"}
 #{"Fudge Brownie" "Half Baked"}
 #{"Fudge Brownie" "Salted Caramel Brownie" "Half Baked"}
 #{"Fudge Brownie" "Caramel Sutra" "Half Baked"}
 #{"Peanut Butter Cup"}
 #{"Peanut Butter Cup" "Caramel Sutra" "Salted Caramel Brownie" "Caramel Chew Chew" "Half Baked" "Cookie Dough"}
 #{"Peanut Butter Cup" "Fudge Brownie" "Caramel Sutra" "Salted Caramel Brownie" "Caramel Chew Chew" "Half Baked" "Cookie Dough"}) 
#+end_src

#+begin_src clojure :export :both
(intents ben-and-jerrys-ctx)
#+end_src

#+RESULTS
#+begin_src text
(#{}
 #{"Brownie"}
 #{"Choco Pieces"}
 #{"Choco Pieces" "Caramel"}
 #{"Choco Pieces" "Vanilla"}
 #{"Choco Pieces" "Brownie" "Vanilla"}
 #{"Choco Pieces" "Brownie" "Vanilla" "Caramel"}
 #{"Choco Pieces" "Caramel Ice" "Caramel"}
 #{"Choco Pieces" "Dough" "Vanilla"}
 #{"Peanut Ice" "Choco Pieces" "Peanut Butter"}
 #{"Choco Ice"}
 #{"Choco Ice" "Brownie"}
 #{"Choco Ice" "Choco Pieces"}
 #{"Choco Ice" "Choco Pieces" "Caramel Ice" "Caramel"}
 #{"Choco Ice" "Choco Pieces" "Brownie" "Dough" "Vanilla"}
 #{"Choco Ice" "Peanut Ice" "Choco Pieces" "Brownie" "Dough" "Peanut Butter" "Caramel Ice" "Vanilla" "Caramel"})
#+end_src

In combination, the extents and intents form the formal concepts:

#+begin_src clojure :export :both
(concepts ben-and-jerrys-ctx)
#+end_src

#+RESULTS
#+begin_src text
([#{"Peanut Butter Cup" "Fudge Brownie" "Caramel Sutra" "Salted Caramel Brownie" "Caramel Chew Chew" "Half Baked" "Cookie Dough"} #{}]
 [#{"Fudge Brownie" "Caramel Sutra" "Half Baked"} #{"Choco Ice"}]
 [#{} #{"Choco Ice" "Peanut Ice" "Choco Pieces" "Brownie" "Dough" "Peanut Butter" "Caramel Ice" "Vanilla" "Caramel"}]
 [#{"Caramel Sutra" "Half Baked"} #{"Choco Ice" "Choco Pieces"}]
 [#{"Half Baked"} #{"Choco Ice" "Choco Pieces" "Brownie" "Dough" "Vanilla"}]
 [#{"Caramel Sutra"} #{"Choco Ice" "Choco Pieces" "Caramel Ice" "Caramel"}]
 [#{"Fudge Brownie" "Half Baked"} #{"Choco Ice" "Brownie"}]
 [#{"Peanut Butter Cup"} #{"Peanut Ice" "Choco Pieces" "Peanut Butter"}]
 [#{"Peanut Butter Cup" "Caramel Sutra" "Salted Caramel Brownie" "Caramel Chew Chew" "Half Baked" "Cookie Dough"} #{"Choco Pieces"}]
 [#{"Salted Caramel Brownie" "Half Baked"} #{"Choco Pieces" "Brownie" "Vanilla"}]
 [#{"Salted Caramel Brownie"} #{"Choco Pieces" "Brownie" "Vanilla" "Caramel"}]
 [#{"Half Baked" "Cookie Dough"} #{"Choco Pieces" "Dough" "Vanilla"}]
 [#{"Caramel Sutra" "Caramel Chew Chew"} #{"Choco Pieces" "Caramel Ice" "Caramel"}]
 [#{"Salted Caramel Brownie" "Half Baked" "Cookie Dough"} #{"Choco Pieces" "Vanilla"}]
 [#{"Caramel Sutra" "Salted Caramel Brownie" "Caramel Chew Chew"} #{"Choco Pieces" "Caramel"}]
 [#{"Fudge Brownie" "Salted Caramel Brownie" "Half Baked"} #{"Brownie"}])
#+end_src

The concept lattice can be computed via

#+begin_src clojure :result silent
(def ben-and-jerrys-lattice (concept-lattice ben-and-jerrys-ctx)
#+end_src

#+begin_src clojure :export :both
ben-and-jerrys-lattice
#+end_src

#+RESULTS
#+begin_src text
Lattice on 16 elements.
#+end_src

The lattice consists of a ~base-set~ (~(base-set ben-and-jerrys-lattice)~ contains the 
concepts from the previous example) and an ~order~ function. The next section will 
explain how to draw a concept lattice.

*** Draw the concept lattice

To be able to draw concept lattices, first use this command once:
#+begin_src clojure :results silent
(use 'conexp.gui.draw)
#+end_src

You can either draw the lattice from the initial context.

#+begin_src clojure :results silent
(draw-concept-lattice ben-and-jerrys-ctx)
#+end_src

You can also draw the already computed ~ben-and-jerrys-lattice~.

#+begin_src clojure :result silent
(draw-lattice ben-and-jerrys-lattice)
#+end_src

The lattice will appear in a new window.

#+caption: Concept lattice of ben-and-jerrys context
[[./images/ben-and-jerrys-lattice.png]]

In left bar of the ~Lattice~ window, you have several options, e.g., you can change the 
layout and turn on the labels. In addition, you have the option to show several 
valuations, like probability, distributivity and support.

The ~ben-and-jerrys-lattice~ with DimDraw layout, labels and support looks like this:

#+caption: Concept lattice of ben-and-jerrys context with DimDraw layout, labels and 
support
[[./images/ben-and-jerrys-lattice-dimdraw-labels-support.png]]

You can also create your own valuations, e.g., the extent and intent size of each formal 
concept.

#+begin_src clojure :result silent
(draw-concept-lattice ben-and-jerrys-ctx 
                      :value-fn (fn [concept]
                                  [(count (first c)) (count (second c))]))
#+end_src

After enabeling the labels, the concept lattice looks like this:

#+caption: Concept lattice of ben-and-jerrys context with manually set valuations
[[./images/ben-and-jerrys-lattice-manual_valuations.png]]

*** Outputs


** Computing implications

*** Canonical base

The canonical base of a context can be computed with:

#+begin_src clojure :exports both
(canonical-base ben-and-jerrys-ctx)
#+end_src

#+RESULTS
#+begin_src text
((#{"Caramel"} ⟶  #{"Choco Pieces"})
 (#{"Vanilla"} ⟶  #{"Choco Pieces"})
 (#{"Caramel Ice"} ⟶  #{"Choco Pieces" "Caramel"})
 (#{"Peanut Butter"} ⟶  #{"Peanut Ice" "Choco Pieces"})
 (#{"Dough"} ⟶  #{"Choco Pieces" "Vanilla"})
 (#{"Choco Pieces" "Vanilla" "Caramel"} ⟶  #{"Brownie"})
 (#{"Choco Pieces" "Brownie"} ⟶  #{"Vanilla"})
 (#{"Choco Pieces" "Brownie" "Caramel Ice" "Vanilla" "Caramel"} ⟶  #{"Choco Ice" "Peanut Ice" "Dough" "Peanut Butter"})
 (#{"Choco Pieces" "Brownie" "Dough" "Vanilla"} ⟶  #{"Choco Ice"})
 (#{"Peanut Ice"} ⟶  #{"Choco Pieces" "Peanut Butter"})
 (#{"Peanut Ice" "Choco Pieces" "Peanut Butter" "Caramel"} ⟶  #{"Choco Ice" "Brownie" "Dough" "Caramel Ice" "Vanilla"})
 (#{"Peanut Ice" "Choco Pieces" "Peanut Butter" "Vanilla"} ⟶  #{"Choco Ice" "Brownie" "Dough" "Caramel Ice" "Caramel"})
 (#{"Choco Ice" "Choco Pieces" "Caramel"} ⟶  #{"Caramel Ice"})
 (#{"Choco Ice" "Choco Pieces" "Vanilla"} ⟶  #{"Brownie" "Dough"})
 (#{"Choco Ice" "Peanut Ice" "Choco Pieces" "Peanut Butter"} ⟶  #{"Brownie" "Dough" "Caramel Ice" "Vanilla" "Caramel"}))
#+end_src


** Scaling data and scale-measures

** Attribute exploration

~conexp-clj~ offers a function for attribute exploration. 

#+begin_src clojure :results silent
(attribute-exploration :context small-ben-and-jerrys-ctx)
#+end_src

The following attribute exploration is interactive. For a suggested implication, the 
user accepts or rejects it with ~yes~ or ~no~:

#+begin_src text
Does the implication (#{Vanilla} ⟶  #{Choco Pieces Dough}) hold? no
#+end_src

If an implication is rejected, a counterexample needs to be provided. First, the object 
of the counterexample needs to be given. In this case, we use the "Salted Caramel Brownie" 
ice cream type from the original ben-and-jerrys-ctx.

#+begin_src text
Then please provide a counterexample
counterexample> object
Please enter new object: "Salted Caramel Brownie"
#+end_src

After that, the attributes of the counterexample are given in the following input format.

#+begin_src text
counterexample> attributes
Please enter new attributes: "Brownie" "Choco Pieces" "Vanilla"
#+end_src

The process of providing a counterexample is finished with the input ~q~. It is possible 
to give another counterexample.

#+begin_src text
counterexample> q
Do you want to give another counterexample? no
#+end_src

The following example shows the attribute exploration of the small-ben-and-jerrys-ctx 
with knowledge from the original ben-and-jerrys-ctx. In the end, the attribute exploration 
returns the list of learned implications and the new context, which in this case is a 
subcontext of the original ben-and-jerrys context.

#+begin_src text
conexp.main=> (explore-attributes :context small-ben-and-jerrys-ctx)
Does the implication (#{Vanilla} ⟶  #{Choco Pieces Dough}) hold? no
Then please provide a counterexample
counterexample> object
Please enter new object: "Salted Caramel Brownie"
counterexample> attributes
Please enter new attributes: "Brownie" "Choco Pieces" "Vanilla"
counterexample> q
Do you want to give another counterexample? no
Does the implication (#{Vanilla} ⟶  #{Choco Pieces}) hold? yes
Does the implication (#{Dough} ⟶  #{Choco Pieces Vanilla}) hold? yes  
Does the implication (#{Choco Pieces} ⟶  #{Vanilla}) hold? no
Then please provide a counterexample
counterexample> object
Please enter new object: "Caramel Chew Chew"
counterexample> attributes
Please enter the attributes the new object should have: "Choco Pieces"
counterexample> q
Do you want to give another counterexample? no
Does the implication (#{Choco Pieces Brownie} ⟶  #{Vanilla}) hold? yes
Does the implication (#{Choco Pieces Brownie Dough Vanilla} ⟶  #{Choco Ice}) hold? yes
Does the implication (#{Choco Ice} ⟶  #{Brownie}) hold? no
Then please provide a counterexample
counterexample> object
Please enter new object: "Caramel Sutra"
counterexample> attributes
Please enter the attributes the new object should have: "Choco Ice" "Choco Pieces"
counterexample> q
Do you want to give another counterexample? no
Does the implication (#{Choco Ice Choco Pieces Vanilla} ⟶  #{Brownie Dough}) hold? yes
{:implications #{(#{"Choco Pieces" "Brownie"} ⟶  #{"Vanilla"})
                 (#{"Vanilla"} ⟶  #{"Choco Pieces"})
                 (#{"Choco Ice" "Choco Pieces" "Vanilla"} ⟶  #{"Brownie" "Dough"})
                 (#{"Choco Pieces" "Brownie" "Dough" "Vanilla"} ⟶  #{"Choco Ice"})
                 (#{"Dough"} ⟶  #{"Choco Pieces" "Vanilla"})},
 :context              |Brownie Choco Ice Choco Pieces Dough Vanilla 
-----------------------+---------------------------------------------
Caramel Chew Chew      |.       .         x            .     .       
Salted Caramel Brownie |x       .         x            .     x       
Caramel Sutra          |.       x         x            .     .       
Cookie Dough           |.       .         x            x     x       
Fudge Brownie          |x       x         .            .     .       
Half Baked             |x       x         x            x     x       
}
#+end_src
